import type {
  Amenity,
  BrandData,
  LocationInfo,
  MenuCategory,
  MenuItem,
  RelatedBrand,
  ReviewSummary,
  SocialLinks,
} from "@/types/brand";

const DEFAULT_REVALIDATE_SECONDS = process.env.NODE_ENV === "development" ? 0 : 300;

function requireEnv(name: string) {
  const value = process.env[name];
  if (!value) {
    throw new Error(`Missing required env var: ${name}`);
  }
  return value;
}

function toSlug(input: string) {
  return input
    .trim()
    .toLowerCase()
    .replace(/['’]/g, "")
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "");
}

function cleanCellText(value: string) {
  const trimmed = value.trim();
  if (!trimmed) return "";
  if (/^generated by ai based on general information/i.test(trimmed)) return "";
  return trimmed;
}

function normalizeHeader(value: string) {
  return value.trim().replace(/:+$/, "").replace(/\s+/g, " ");
}

function splitList(value: string): string[] {
  const cleaned = cleanCellText(value);
  if (!cleaned) return [];
  return cleaned
    .split(/[\n,•|]+/g)
    .map((item) => item.trim())
    .filter(Boolean);
}

function parseGeneralInfo(value: string): {
  address?: string;
  phone?: string;
  openingHours?: string;
  website?: string;
  rating?: number;
  reviewCount?: number;
  imageUrl?: string;
  priceRange?: string;
  details?: string;
  distance?: string;
  cuisine?: string[];
  diningStyle?: string[];
} {
  const text = cleanCellText(value);
  if (!text) return {};

  const labels = [
    "Name",
    "Reviews",
    "Address",
    "Phone",
    "Price",
    "Opening Hours",
    "Weekly Schedule",
    "Website",
    "Cuisine",
    "Image URL",
    "Dining Style",
    "Details",
    "Distance",
  ];

  const extract = (label: string) => {
    const startMatch = text.match(new RegExp(`${label}\\s*:\\s*`, "i"));
    if (!startMatch || startMatch.index === undefined) return undefined;
    const start = startMatch.index + startMatch[0].length;

    const remaining = text.slice(start);
    const nextLabelRegex = new RegExp(
      `\\b(?:${labels.filter((l) => l.toLowerCase() !== label.toLowerCase()).join("|")})\\s*:`,
      "i",
    );
    const nextMatch = remaining.match(nextLabelRegex);
    const end = nextMatch && nextMatch.index !== undefined ? start + nextMatch.index : text.length;
    return text.slice(start, end).trim();
  };

  const address = extract("Address");
  const phone = extract("Phone");
  const priceRange = extract("Price");
  const weeklySchedule = extract("Weekly Schedule");
  const openingHours = weeklySchedule || extract("Opening Hours");
  const website = extract("Website");
  const details = extract("Details");
  const distance = extract("Distance");
  const cuisine = splitList(extract("Cuisine") ?? "");
  const diningStyle = splitList(extract("Dining Style") ?? "");

  const reviewsText = extract("Reviews") ?? "";
  const ratingMatch = reviewsText.match(/([0-9]+(?:\\.[0-9]+)?)/);
  const countMatch = reviewsText.match(/\\((\\d+)\\)/);

  const rating = ratingMatch ? Number(ratingMatch[1]) : undefined;
  const reviewCount = countMatch ? Number(countMatch[1]) : undefined;

  const imageUrl = extract("Image URL");

  return {
    address,
    phone,
    openingHours,
    website,
    rating,
    reviewCount,
    imageUrl,
    priceRange,
    details,
    distance,
    cuisine,
    diningStyle,
  };
}

function mergeGeneralInfo(
  primary: ReturnType<typeof parseGeneralInfo>,
  fallback?: ReturnType<typeof parseGeneralInfo>,
) {
  if (!fallback) return primary;
  return {
    address: primary.address || fallback.address,
    phone: primary.phone || fallback.phone,
    openingHours: primary.openingHours || fallback.openingHours,
    website: primary.website || fallback.website,
    rating: primary.rating || fallback.rating,
    reviewCount: primary.reviewCount || fallback.reviewCount,
    imageUrl: primary.imageUrl || fallback.imageUrl,
    priceRange: primary.priceRange || fallback.priceRange,
    details: primary.details || fallback.details,
    distance: primary.distance || fallback.distance,
    cuisine: primary.cuisine?.length ? primary.cuisine : fallback.cuisine,
    diningStyle: primary.diningStyle?.length ? primary.diningStyle : fallback.diningStyle,
  };
}

function parseGeneralInfoByLocation(value: string) {
  const text = cleanCellText(value);
  const byLocation: Record<string, ReturnType<typeof parseGeneralInfo>> = {};
  if (!text) return byLocation;

  // Expected format: "<Location Name> - Name: ... Reviews: ... Address: ...".
  const blocks = text
    .split(/\n\s*\n/g)
    .map((block) => block.trim())
    .filter(Boolean);

  for (const block of blocks) {
    const match = block.match(/^(.+?)\s*-\s*([\s\S]+)$/);
    if (!match) continue;
    const locationName = match[1].trim();
    const details = match[2].trim();
    if (!locationName || !details) continue;
    byLocation[toSlug(locationName)] = parseGeneralInfo(details);
  }

  // If we can't detect per-location blocks, fall back to parsing the entire cell.
  if (Object.keys(byLocation).length === 0) {
    byLocation["__default__"] = parseGeneralInfo(text);
  }

  return byLocation;
}

function parseTextByLocation(value: string) {
  const text = cleanCellText(value);
  const byLocation: Record<string, string> = {};
  if (!text) return { byLocation, defaultText: "" };

  const blocks = text
    .split(/\n\s*\n/g)
    .map((block) => block.trim())
    .filter(Boolean);

  let hasLocationBlocks = false;
  let currentLocationSlug: string | null = null;

  for (const block of blocks) {
    const line = block.split("\n")[0]?.trim() ?? "";
    if (line.endsWith("-") && line.length <= 80) {
      const locationName = line.replace(/-$/, "").trim();
      currentLocationSlug = locationName ? toSlug(locationName) : null;
      if (currentLocationSlug) hasLocationBlocks = true;
      const remainder = block.split("\n").slice(1).join("\n").trim();
      if (currentLocationSlug && remainder) {
        byLocation[currentLocationSlug] = remainder;
        currentLocationSlug = null;
      }
      continue;
    }

    const match = block.match(/^(.+?)\s*-\s*([\s\S]+)$/);
    if (match) {
      const locationName = match[1].trim();
      const details = match[2].trim();
      if (!locationName || !details) continue;
      byLocation[toSlug(locationName)] = details;
      currentLocationSlug = toSlug(locationName);
      hasLocationBlocks = true;
      continue;
    }

    if (currentLocationSlug) {
      byLocation[currentLocationSlug] = block.trim();
      hasLocationBlocks = true;
      currentLocationSlug = null;
    }
  }

  if (!hasLocationBlocks) {
    return { byLocation, defaultText: text };
  }

  return { byLocation, defaultText: text };
}

function parseAmenityListByLocation(value: string) {
  const text = cleanCellText(value);
  const byLocation: Record<string, Amenity[]> = {};
  if (!text) return { byLocation, defaultAmenities: [] };

  const blocks = text
    .split(/\n\s*\n/g)
    .map((block) => block.trim())
    .filter(Boolean);

  let hasLocationBlocks = false;
  let currentLocationSlug: string | null = null;

  for (const block of blocks) {
    const line = block.split("\n")[0]?.trim() ?? "";
    if (line.endsWith("-") && line.length <= 80) {
      const locationName = line.replace(/-$/, "").trim();
      currentLocationSlug = locationName ? toSlug(locationName) : null;
      if (currentLocationSlug) hasLocationBlocks = true;
      const remainder = block.split("\n").slice(1).join("\n").trim();
      if (currentLocationSlug && remainder) {
        const amenities = splitList(remainder).map((label) => ({ label }));
        byLocation[currentLocationSlug] = amenities;
        currentLocationSlug = null;
      }
      continue;
    }

    const match = block.match(/^(.+?)\s*-\s*([\s\S]+)$/);
    if (match) {
      const locationName = match[1].trim();
      const details = match[2].trim();
      if (!locationName || !details) continue;
      const amenities = splitList(details).map((label) => ({ label }));
      byLocation[toSlug(locationName)] = amenities;
      currentLocationSlug = toSlug(locationName);
      hasLocationBlocks = true;
      continue;
    }

    if (currentLocationSlug) {
      const amenities = splitList(block).map((label) => ({ label }));
      byLocation[currentLocationSlug] = amenities;
      hasLocationBlocks = true;
      currentLocationSlug = null;
    }
  }

  if (!hasLocationBlocks) {
    return { byLocation, defaultAmenities: splitList(text).map((label) => ({ label })) };
  }

  return { byLocation, defaultAmenities: [] };
}

function parseKeyedValueMap(value: string) {
  const text = cleanCellText(value);
  const result: Record<string, string> = {};
  if (!text) return result;

  const lines = text
    .split("\n")
    .map((line) => line.trim())
    .filter(Boolean);

  for (const line of lines) {
    const match =
      line.match(/^(.+?)\s*[-:]\s*(.+)$/) ?? line.match(/^(.+?)\s*\|\s*(.+)$/);
    if (!match) continue;
    const locationName = match[1].trim();
    const valueText = match[2].trim();
    if (!locationName || !valueText) continue;
    result[toSlug(locationName)] = valueText;
  }

  return result;
}

function parseFoodMenu(value: string): MenuCategory[] {
  const text = cleanCellText(value);
  if (!text) return [];

  const lines = text.split("\n");
  const categories: MenuCategory[] = [];
  let currentCategory: MenuCategory | null = null;

  const pushCategory = () => {
    if (!currentCategory) return;
    if (currentCategory.items.length === 0) return;
    categories.push(currentCategory);
  };

  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line) continue;

    const itemMatch = line.match(/^(.+?)\s*-\s*(https?:\/\/\S+)(?:\s*-\s*(.+))?$/);
    if (itemMatch) {
      const itemName = itemMatch[1].trim();
      const imageUrl = itemMatch[2].trim();
      const trailing = itemMatch[3]?.trim();
      const item: MenuItem = {
        name: itemName,
        imageUrl,
        price: trailing && /\$/.test(trailing) ? trailing : undefined,
      };

      if (!currentCategory) {
        currentCategory = { name: "Menu", items: [] };
      }
      currentCategory.items.push(item);
      continue;
    }

    // If the line doesn't look like an item, treat it as a category header.
    pushCategory();
    currentCategory = { name: line, items: [] };
  }

  pushCategory();
  return categories;
}

function parseSocialLinks(value: string): SocialLinks {
  const text = cleanCellText(value);
  if (!text) return {};

  const urls = text.match(/https?:\/\/\S+/g) ?? [];
  const links: SocialLinks = {};

  for (const url of urls) {
    const lower = url.toLowerCase();
    if (lower.includes("facebook.com")) links.facebook = url;
    if (lower.includes("instagram.com")) links.instagram = url;
    if (lower.includes("linkedin.com")) links.linkedin = url;
  }

  return links;
}

function parsePromotions(value: string): string[] {
  const text = cleanCellText(value);
  if (!text) return [];
  const urls = text.match(/https?:\/\/\S+/g) ?? [];
  return urls;
}

function parseCoupons(value: string): string[] {
  const text = cleanCellText(value);
  if (!text) return [];
  return text
    .split(/\n+/)
    .map((line) => line.trim())
    .filter(Boolean);
}

function parseRecommendations(value: string): string[] {
  return splitList(value);
}

function buildLocations(args: {
  locationNames: string[];
  generalInfo: ReturnType<typeof parseGeneralInfo>;
  generalInfoByLocation: Record<string, ReturnType<typeof parseGeneralInfo>>;
  locationDetailsBySlug: Record<string, string>;
  locationImageBySlug: Record<string, string>;
  openingHoursBySlug: Record<string, string>;
  descriptionBySlug: Record<string, string>;
  amenitiesBySlug: Record<string, Amenity[]>;
  defaultDescription: string;
  defaultAmenities: Amenity[];
}): LocationInfo[] {
  return args.locationNames.map((locationName) => {
    const slug = toSlug(locationName);
    const locationGeneral =
      args.generalInfoByLocation[slug] ??
      args.generalInfoByLocation["__default__"] ??
      args.generalInfo;

    const address = locationGeneral.address ?? "";

    const openingHours =
      args.openingHoursBySlug[slug] ??
      locationGeneral.openingHours ??
      "";

    const heroImageUrl =
      args.locationImageBySlug[slug] ?? locationGeneral.imageUrl ?? "";

    const imageUrl =
      locationGeneral.imageUrl ?? args.locationImageBySlug[slug] ?? "";

    const description = args.descriptionBySlug[slug] ?? args.defaultDescription;
    const amenities = args.amenitiesBySlug[slug] ?? args.defaultAmenities;

    return {
      slug,
      name: locationName,
      address,
      phone: locationGeneral.phone ?? "",
      reviews: {
        rating: locationGeneral.rating ?? 0,
        count: locationGeneral.reviewCount ?? 0,
      },
      openingHours,
      website: locationGeneral.website ?? "",
      imageUrl,
      heroImageUrl,
      priceRange: locationGeneral.priceRange,
      details: args.locationDetailsBySlug[slug] ?? locationGeneral.details,
      distance: locationGeneral.distance,
      cuisine: locationGeneral.cuisine ?? [],
      diningStyle: locationGeneral.diningStyle ?? [],
      description,
      amenities,
      descriptionMissing: !description,
      amenitiesMissing: amenities.length === 0,
    };
  });
}

function buildReviewSummaries(locations: LocationInfo[]): ReviewSummary[] {
  return locations.map((location) => ({
    location: location.name,
    rating: location.reviews.rating,
    totalReviews: location.reviews.count,
    reviews: [],
  }));
}

function parseGoogleReviewsByLocation(
  value: string,
  locations: LocationInfo[],
): ReviewSummary[] {
  const text = cleanCellText(value);
  if (!text) return [];

  const locationNameBySlug = new Map(
    locations.map((location) => [location.slug, location.name]),
  );
  const summariesBySlug = new Map<string, ReviewSummary>();

  const resolveLocationName = (raw: string) => {
    const slug = toSlug(raw);
    return locationNameBySlug.get(slug) ?? raw.trim();
  };

  const parseLocationHeader = (line: string) => {
    const dashMatch = line.match(
      /^(.+?)\s*-\s*([0-9]+(?:\.[0-9]+)?)(?:\s*\/\s*5)?\s*\(?\s*([0-9]+)?\s*Reviews?\)?/i,
    );
    if (dashMatch) {
      return {
        location: dashMatch[1].trim(),
        rating: Number(dashMatch[2]),
        totalReviews: dashMatch[3] ? Number(dashMatch[3]) : 0,
      };
    }

    const reviewsMatch = line.match(
      /^(.+?)\s*Reviews?\s*:\s*([0-9]+(?:\.[0-9]+)?)(?:\s*\/\s*5)?\s*\(?\s*([0-9]+)?/i,
    );
    if (reviewsMatch) {
      return {
        location: reviewsMatch[1].trim(),
        rating: Number(reviewsMatch[2]),
        totalReviews: reviewsMatch[3] ? Number(reviewsMatch[3]) : 0,
      };
    }

    return null;
  };

  const lines = text.split(/\r?\n/);
  let currentSummary: ReviewSummary | null = null;
  let currentReview: { author: string; rating: number; date: string; content: string } | null =
    null;

  const flushReview = () => {
    if (!currentSummary || !currentReview) return;
    if (!currentReview.content.trim()) return;
    currentSummary.reviews.push({ ...currentReview, content: currentReview.content.trim() });
    currentReview = null;
  };

  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line) {
      flushReview();
      continue;
    }

    const header = parseLocationHeader(line);
    if (header) {
      flushReview();
      const locationName = resolveLocationName(header.location);
      const slug = toSlug(locationName);
      const existing = summariesBySlug.get(slug);
      const summary =
        existing ??
        ({
          location: locationName,
          rating: header.rating || 0,
          totalReviews: header.totalReviews || 0,
          reviews: [],
        } as ReviewSummary);

      if (!existing) summariesBySlug.set(slug, summary);

      if (header.rating) summary.rating = header.rating;
      if (header.totalReviews) summary.totalReviews = header.totalReviews;

      currentSummary = summary;
      continue;
    }

    const reviewMatch = line.match(
      /^(.+?)\s*\((\d+)\s*star[s]?\s*review\)\s*\(([^)]+)\)\s*(.*)$/i,
    );
    if (reviewMatch) {
      flushReview();
      if (!currentSummary) continue;
      currentReview = {
        author: reviewMatch[1].trim(),
        rating: Number(reviewMatch[2]),
        date: reviewMatch[3].trim(),
        content: reviewMatch[4]?.trim() ?? "",
      };
      continue;
    }

    if (currentReview) {
      currentReview.content = `${currentReview.content} ${line}`.trim();
    }
  }

  flushReview();
  return Array.from(summariesBySlug.values());
}

function parseRelatedBrands(value: string, locationNames: string[]): Record<string, RelatedBrand[]> {
  const text = cleanCellText(value);
  const byLocation: Record<string, RelatedBrand[]> = {};

  for (const locationName of locationNames) {
    byLocation[toSlug(locationName)] = [];
  }

  if (!text) return byLocation;

  const labels = [
    "Name",
    "Unit",
    "Price",
    "Reviews",
    "Cuisine",
    "Dining Style",
    "Opening Hours",
    "Image URL",
    "Location",
  ];

  const parseRatingAndCount = (input: string) => {
    const ratingMatch = input.match(/([0-9]+(?:\\.[0-9]+)?)/);
    const countMatch = input.match(/\\((\\d+)\\)/);
    return {
      rating: ratingMatch ? Number(ratingMatch[1]) : 0,
      reviewCount: countMatch ? Number(countMatch[1]) : 0,
    };
  };

  const fieldValue = (flat: string, label: string) => {
    const idx = flat.toLowerCase().indexOf(`${label.toLowerCase()}:`);
    if (idx === -1) return "";
    const start = idx + label.length + 1;

    let end = flat.length;
    for (const other of labels) {
      if (other.toLowerCase() === label.toLowerCase()) continue;
      const nextIdx = flat.toLowerCase().indexOf(`${other.toLowerCase()}:`, start);
      if (nextIdx !== -1) end = Math.min(end, nextIdx);
    }

    return flat.slice(start, end).trim();
  };

  const blocks = text
    .split(/\n\s*\n/g)
    .map((block) => block.trim())
    .filter(Boolean);

  let currentLocationSlug: string | null = null;
  let currentLocationName = "";

  for (const block of blocks) {
    const firstLine = block.split("\n")[0]?.trim() ?? "";
    if (firstLine.endsWith("-") && !firstLine.toLowerCase().startsWith("name:")) {
      currentLocationName = firstLine.replace(/-$/, "").trim();
      currentLocationSlug = currentLocationName ? toSlug(currentLocationName) : null;
      if (currentLocationSlug && !byLocation[currentLocationSlug]) {
        byLocation[currentLocationSlug] = [];
      }
      continue;
    }

    const flat = block.replace(/\r?\n/g, " ").replace(/\s+/g, " ").trim();
    const name = fieldValue(flat, "Name");

    if (name) {
      const reviewsRaw = fieldValue(flat, "Reviews");
      const { rating, reviewCount } = reviewsRaw
        ? parseRatingAndCount(reviewsRaw)
        : { rating: 0, reviewCount: 0 };
      const cuisines = splitList(fieldValue(flat, "Cuisine"));
      const diningStyles = splitList(fieldValue(flat, "Dining Style"));

      const related: RelatedBrand = {
        name,
        location: fieldValue(flat, "Location") || currentLocationName,
        rating,
        reviewCount,
        imageUrl: fieldValue(flat, "Image URL"),
        openingHours: fieldValue(flat, "Opening Hours"),
        price: fieldValue(flat, "Price") || undefined,
        unit: fieldValue(flat, "Unit") || undefined,
        cuisines: cuisines.length ? cuisines : undefined,
        diningStyles: diningStyles.length ? diningStyles : undefined,
      };

      if (currentLocationSlug && byLocation[currentLocationSlug]) {
        byLocation[currentLocationSlug].push(related);
      } else {
        for (const slug of Object.keys(byLocation)) {
          byLocation[slug].push(related);
        }
      }

      continue;
    }

    const line = flat;
    const [locationPart, rest] =
      line.includes(":") ? line.split(/:(.+)/).slice(0, 2) : ["", line];
    const locationSlug = locationPart ? toSlug(locationPart) : currentLocationSlug ?? "";
    const tokens = rest.split("-").map((t) => t.trim()).filter(Boolean);
    if (tokens.length === 0) continue;

    const fallbackName = tokens[0] ?? "Related brand";
    const ratingMatch = rest.match(/([0-9]+(?:\\.[0-9]+)?)\\s*\\((\\d+)\\)/);
    const rating = ratingMatch ? Number(ratingMatch[1]) : 0;
    const reviewCount = ratingMatch ? Number(ratingMatch[2]) : 0;
    const imageUrl = (rest.match(/https?:\/\/\S+/) ?? [])[0] ?? "";
    const openingHours = tokens.find((t) => /am|pm|hours|open/i.test(t)) ?? "";

    const related: RelatedBrand = {
      name: fallbackName,
      location: locationPart || currentLocationName,
      rating,
      reviewCount,
      imageUrl,
      openingHours,
    };

    if (locationSlug && byLocation[locationSlug]) {
      byLocation[locationSlug].push(related);
    } else {
      for (const slug of Object.keys(byLocation)) {
        byLocation[slug].push(related);
      }
    }
  }

  return byLocation;
}

async function fetchSheetTitle() {
  const spreadsheetId = requireEnv("GOOGLE_SHEETS_SPREADSHEET_ID");
  const apiKey = requireEnv("GOOGLE_SHEETS_API_KEY");
  const url = new URL(`https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}`);
  url.searchParams.set("key", apiKey);
  url.searchParams.set("fields", "sheets(properties(title))");

  const response = await fetch(url.toString(), {
    next: { revalidate: DEFAULT_REVALIDATE_SECONDS },
  });
  if (!response.ok) {
    throw new Error(
      `Google Sheets metadata request failed: ${response.status} ${response.statusText}`,
    );
  }

  const json = (await response.json()) as {
    sheets?: { properties?: { title?: string } }[];
  };

  const titles =
    json.sheets
      ?.map((sheet) => sheet.properties?.title)
      .filter((title): title is string => Boolean(title)) ?? [];

  if (titles.length === 0) throw new Error("Google Sheets: unable to determine sheet title");

  if (process.env.GOOGLE_SHEETS_SHEET_NAME) {
    const desired = process.env.GOOGLE_SHEETS_SHEET_NAME;
    if (titles.includes(desired)) return desired;
  }

  const preferred =
    titles.find((t) => t.toLowerCase() === "assessment") ??
    titles.find((t) => /menu/i.test(t)) ??
    titles[0];

  return preferred;
}

async function fetchSheetValues(rangeA1: string) {
  const spreadsheetId = requireEnv("GOOGLE_SHEETS_SPREADSHEET_ID");
  const apiKey = requireEnv("GOOGLE_SHEETS_API_KEY");
  const url = new URL(
    `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${encodeURIComponent(
      rangeA1,
    )}`,
  );
  url.searchParams.set("key", apiKey);

  const response = await fetch(url.toString(), {
    next: { revalidate: DEFAULT_REVALIDATE_SECONDS },
  });
  if (!response.ok) {
    throw new Error(
      `Google Sheets values request failed: ${response.status} ${response.statusText}`,
    );
  }

  const json = (await response.json()) as { values?: string[][] };
  return json.values ?? [];
}

type AllMenusIndex = Record<string, Record<string, string>>;

function parseAllMenusValues(values: string[][]): AllMenusIndex {
  const index: AllMenusIndex = {};
  if (values.length === 0) return index;

  const headers = values[0] ?? [];
  const locationSlugs = headers.map((header) => toSlug(header));
  locationSlugs.forEach((slug) => {
    if (slug) index[slug] = {};
  });

  for (const row of values.slice(1)) {
    row.forEach((cell, columnIndex) => {
      const text = cell?.toString().trim();
      if (!text) return;
      const locationSlug = locationSlugs[columnIndex];
      if (!locationSlug) return;
      const match = text.match(
        /Name\\s*:\\s*([^\\n]+?)(?:\\s+Reviews\\s*:\\s*|\\s+Address\\s*:\\s*|\\s+Phone\\s*:\\s*|\\s+Opening\\s*Hours\\s*:\\s*|\\s+Website\\s*:\\s*|\\s+Cuisine\\s*:\\s*|\\s+Image\\s*URL\\s*:\\s*|\\s+Dining\\s*Style\\s*:\\s*|$)/i,
      );
      if (!match) return;
      const brandName = match[1]?.trim();
      if (!brandName) return;
      const brandSlug = toSlug(brandName);
      if (!brandSlug) return;
      index[locationSlug][brandSlug] = text;
    });
  }

  return index;
}

function parseRow(
  row: string[],
  headerIndexByName: Record<string, number>,
  allMenusIndex?: AllMenusIndex,
): BrandData | null {
  const getCell = (header: string) => {
    const normalized = normalizeHeader(header).toLowerCase();
    let index = headerIndexByName[normalized];
    if (index === undefined) {
      const fallbackKey = Object.keys(headerIndexByName).find((key) => key.startsWith(normalized));
      if (fallbackKey) index = headerIndexByName[fallbackKey];
    }
    if (index === undefined) return "";
    return row[index] ?? "";
  };

  const name = cleanCellText(getCell("Name"));
  if (!name) return null;
  const slug = toSlug(name);

  const locationNames = splitList(getCell("Location associated"));
  const generalInfo = parseGeneralInfo(getCell("General Information"));
  const generalInfoByLocation = parseGeneralInfoByLocation(getCell("General Information"));

  const allMenusByLocation: Record<string, ReturnType<typeof parseGeneralInfo>> = {};
  if (allMenusIndex) {
    for (const locationName of locationNames) {
      const locationSlug = toSlug(locationName);
      const fallbackText = allMenusIndex[locationSlug]?.[slug];
      if (fallbackText) {
        allMenusByLocation[locationSlug] = parseGeneralInfo(fallbackText);
      }
    }
  }

  const mergedGeneralInfoByLocation: Record<string, ReturnType<typeof parseGeneralInfo>> = {
    ...generalInfoByLocation,
  };
  for (const [locationSlug, fallbackInfo] of Object.entries(allMenusByLocation)) {
    mergedGeneralInfoByLocation[locationSlug] = mergeGeneralInfo(
      generalInfoByLocation[locationSlug] ?? {},
      fallbackInfo,
    );
  }

  const { byLocation: descriptionBySlug, defaultText: defaultDescription } = parseTextByLocation(
    getCell("Description"),
  );
  const { byLocation: amenitiesBySlug, defaultAmenities } = parseAmenityListByLocation(
    getCell("Amenities & Features"),
  );

  const menu = parseFoodMenu(getCell("Food Menu"));

  const locationDetailsBySlug = parseKeyedValueMap(getCell("Location Details"));
  const openingHoursBySlug = parseKeyedValueMap(getCell("Opening Hours"));
  const locationImageRaw =
    getCell("Img Src") ||
    getCell("Img src") ||
    getCell("Img src:") ||
    getCell("Img Src:") ||
    getCell("Header Image") ||
    getCell("Hero Image");
  const locationImageBySlug = parseKeyedValueMap(locationImageRaw);

  const locations = buildLocations({
    locationNames,
    generalInfo,
    generalInfoByLocation: mergedGeneralInfoByLocation,
    locationDetailsBySlug,
    locationImageBySlug,
    openingHoursBySlug,
    descriptionBySlug,
    amenitiesBySlug,
    defaultDescription,
    defaultAmenities,
  });

  const description = defaultDescription;
  const youtubeUrl = cleanCellText(getCell("Youtube Video")) || undefined;
  const socialLinks = parseSocialLinks(getCell("Social Medias"));
  const promotions = parsePromotions(getCell("Latest Promotions"));
  const recommendations = parseRecommendations(getCell("BestFoodWhere's Recommendation"));
  const coupons = parseCoupons(
    getCell("Exclusive Coupons") || getCell("Exclusive Coupon") || getCell("Coupons"),
  );

  const googleReviewSummaries = parseGoogleReviewsByLocation(getCell("Google Reviews"), locations);
  const locationsWithReviews = locations.map((location) => {
    const summary = googleReviewSummaries.find(
      (item) => toSlug(item.location) === location.slug,
    );
    if (!summary) return location;
    if (!summary.rating && !summary.totalReviews) return location;
    return {
      ...location,
      reviews: {
        rating: summary.rating || location.reviews.rating,
        count: summary.totalReviews || location.reviews.count,
      },
    };
  });
  const reviews =
    googleReviewSummaries.length > 0
      ? googleReviewSummaries
      : buildReviewSummaries(locationsWithReviews);
  const relatedBrands = parseRelatedBrands(getCell("More bakeries"), locationNames);

  return {
    name,
    slug,
    locations: locationsWithReviews,
    description,
    amenities: defaultAmenities,
    menu,
    youtubeUrl,
    reviews,
    relatedBrands,
    socialLinks,
    promotions,
    recommendations,
    coupons,
    descriptionMissing: !description,
    amenitiesMissing: defaultAmenities.length === 0,
  };
}

export async function fetchAllBrands(): Promise<BrandData[]> {
  const sheetTitle = await fetchSheetTitle();
  const range =
    process.env.GOOGLE_SHEETS_RANGE ??
    (process.env.GOOGLE_SHEETS_SHEET_NAME
      ? `${process.env.GOOGLE_SHEETS_SHEET_NAME}!A:Z`
      : `${sheetTitle}!A:Z`);

  const values = await fetchSheetValues(range);
  let allMenusIndex: AllMenusIndex | undefined;
  try {
    const allMenusValues = await fetchSheetValues("All Menus!A:Z");
    allMenusIndex = parseAllMenusValues(allMenusValues);
  } catch {
    allMenusIndex = undefined;
  }
  if (values.length === 0) return [];

  const headerRowIndex = values.findIndex((row) => {
    const normalized = row.map((cell) => normalizeHeader(cell).toLowerCase());
    const hasName = normalized.includes("name");
    const hasGeneralInfo = normalized.some((cell) => cell.includes("general information"));
    return hasName && hasGeneralInfo;
  });

  if (headerRowIndex < 0) return [];

  const headers = (values[headerRowIndex] ?? []).map((h) => normalizeHeader(h));
  const headerIndexByName: Record<string, number> = {};
  headers.forEach((h, index) => {
    if (!h) return;
    headerIndexByName[h.toLowerCase()] = index;
  });

  const rows = values.slice(headerRowIndex + 1);

  const brands: BrandData[] = [];
  for (const row of rows) {
    const brand = parseRow(row, headerIndexByName, allMenusIndex);
    if (brand) brands.push(brand);
  }

  return brands;
}

export async function fetchBrandBySlug(slug: string): Promise<BrandData | null> {
  const normalized = toSlug(slug);
  const brands = await fetchAllBrands();
  return brands.find((brand) => brand.slug === normalized) ?? null;
}
